<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Лабораторна 8 - Canvas (Всі фігури)</title>

  <link rel="stylesheet" href="../Lab3/style.css">
  <script src="../js/lab_scripts.js" defer></script>

  <style>
    #drawingCanvas {
      border: 1px dashed red;
      background-color: #fff;
    }
    header, main {
      text-align: center;
    }
    #animateButton {
      font-size: 1em;
      padding: 10px 15px;
    }
  </style>
</head>

<body onload="alert('Завдання 1 (onload): Сторінку (Lab8/canvas.html) повністю завантажено!')">

<header>
  <nav>
    <a href="../Lab3/index.html" title="Головна сторінка">Головна (ЛР3)</a> |
    <a href="../Lab3/company.html" title="Інформація про компанію">Про компанію</a> |
    <a href="../Lab3/news.html" title="Акції та новини">Новини</a> |
    <a href="../Lab3/services.html" title="Наші послуги">Послуги</a> |
    <a href="../Lab3/menu.html" title="Меню сайту">Меню</a> |
    <a href="../Lab4/table.html" title="Лабораторна 4">Таблиці (ЛР4)</a> |
    <a href="../Lab5/form.html" title="Лабораторна 5">Форми (ЛР5)</a> |
    <a href="../Lab6/svg.html" title="Лабораторна 6">SVG (ЛР6)</a> |
    <a href="canvas.html" title="Лабораторна 8">Canvas (ЛР8)</a>
  </nav>
</header>

<main>
  <h1 onclick="alert('Завдання 2 (onclick): Ви натиснули на H1.')">
    Лабораторна робота №8: Малювання на Canvas (Всі фігури з ЛР6)
  </h1>

  <button type="button" id="animateButton" class="lab-task-fieldset button">
    Запустити анімацію (Подія)
  </button>

  <br><br>
  <canvas id="drawingCanvas" width="800" height="500">
    Ваш браузер не підтримує тег canvas
  </canvas>

</main>

<script>
  window.addEventListener('load', () => {

    const canvas = document.getElementById("drawingCanvas");
    const context = canvas.getContext("2d");

    let animationRunning = false;
    let startTime = 0;

    const svgViewBox = {
      minX: -5,
      minY: -4,
      width: 17,
      height: 12
    };

    const hexToRgb = (hex) => {
      const bigint = parseInt(hex.slice(1), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return { r, g, b };
    };

    const rgbToHex = (r, g, b) => {
      const toHex = (c) => Math.round(c).toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    };

    const lerp = (start, end, amount) => {
      return start + (end - start) * amount;
    };

    const interpolateColor = (color1, color2, factor) => {
      const rgb1 = hexToRgb(color1);
      const rgb2 = hexToRgb(color2);

      const r = lerp(rgb1.r, rgb2.r, factor);
      const g = lerp(rgb1.g, rgb2.g, factor);
      const b = lerp(rgb1.b, rgb2.b, factor);

      return rgbToHex(r, g, b);
    };

    const mapX = (svgX) => {
      return (svgX - svgViewBox.minX) / svgViewBox.width * canvas.width;
    };
    const mapY = (svgY) => {
      return ((4 - svgY) - svgViewBox.minY) / svgViewBox.height * canvas.height;
    };
    const mapW = (svgW) => {
      return (svgW / svgViewBox.width) * canvas.width;
    };
    const mapH = (svgH) => {
      return (svgH / svgViewBox.height) * canvas.height;
    };

    const figures = {
      ccCircle: { x: 3, y: 0, r: 2, fill: "#0000FF" },
      movCircle: { x: -2, y: 1, r: 1 },
      rotRect: { x: 0, y: 1, w: 2, h: 1, rotation: 0 },
      sEllipse: { x: -1, y: -1.5, rx: 1, ry: 0.5 },
      skewRect: { x: -3, y: -2, w: 2, h: 1, skewX: 0 },
      staticRect1: { x: 4, y: 1, w: 1, h: 1 },
      staticRect2: { x: 4, y: -2, w: 1, h: 1 },
      staticRect3: { x: 2, y: -2, w: 2, h: 1 },
      staticRect4: { x: -3, y: -1, w: 1, h: 1 }
    };

    const drawFigures = () => {
      context.clearRect(0, 0, canvas.width, canvas.height);

      context.strokeStyle = "#aaa";
      context.lineWidth = 1;
      context.beginPath();
      context.moveTo(mapX(-5), mapY(0));
      context.lineTo(mapX(12), mapY(0));
      context.moveTo(mapX(0), mapY(-4));
      context.lineTo(mapX(0), mapY(8));
      context.stroke();

      const figCC = figures.ccCircle;
      context.fillStyle = figCC.fill;
      context.beginPath();
      context.arc(mapX(figCC.x), mapY(figCC.y), mapW(figCC.r), 0, 2 * Math.PI);
      context.fill();

      const figMC = figures.movCircle;
      context.fillStyle = "blue";
      context.beginPath();
      context.arc(mapX(figMC.x), mapY(figMC.y), mapW(figMC.r), 0, 2 * Math.PI);
      context.fill();

      const figRR = figures.rotRect;
      context.save();
      context.fillStyle = "blue";
      context.translate(mapX(1), mapY(1.5));
      context.rotate(figRR.rotation);
      context.fillRect(mapW(-figRR.w / 2), mapH(-figRR.h / 2), mapW(figRR.w), mapH(figRR.h));
      context.restore();

      const figSE = figures.sEllipse;
      context.fillStyle = "blue";
      context.beginPath();
      context.ellipse(mapX(figSE.x), mapY(figSE.y), mapW(figSE.rx), mapH(figSE.ry), 0, 0, 2 * Math.PI);
      context.fill();

      const figSR = figures.skewRect;
      context.save();
      context.fillStyle = "blue";
      context.transform(1, 0, figSR.skewX, 1, mapX(figSR.x), mapY(figSR.y));
      context.fillRect(0, 0, mapW(figSR.w), mapH(figSR.h));
      context.restore();

      const figS1 = figures.staticRect1;
      context.fillStyle = "blue";
      context.fillRect(mapX(figS1.x), mapY(figS1.y), mapW(figS1.w), mapH(figS1.h));

      const figS2 = figures.staticRect2;
      context.fillStyle = "blue";
      context.fillRect(mapX(figS2.x), mapY(figS2.y), mapW(figS2.w), mapH(figS2.h));

      const figS3 = figures.staticRect3;
      context.fillStyle = "blue";
      context.fillRect(mapX(figS3.x), mapY(figS3.y), mapW(figS3.w), mapH(figS3.h));

      const figS4 = figures.staticRect4;
      context.fillStyle = "blue";
      context.fillRect(mapX(figS4.x), mapY(figS4.y), mapW(figS4.w), mapH(figS4.h));
    };

    const updateAnimation = (timestamp) => {
      if (!animationRunning) return;

      if (startTime === 0) startTime = timestamp;
      const time = (timestamp - startTime) / 1000;

      const colorDur = 10;
      const colorVal = (time % colorDur) / colorDur;
      const phaseDuration = 1 / 3;
      const colors = ["#0000FF", "#FF0000", "#00FF00", "#0000FF"];

      let startColor, endColor, factor;

      if (colorVal < phaseDuration) {
        startColor = colors[0];
        endColor = colors[1];
        factor = colorVal / phaseDuration;
      } else if (colorVal < phaseDuration * 2) {
        startColor = colors[1];
        endColor = colors[2];
        factor = (colorVal - phaseDuration) / phaseDuration;
      } else {
        startColor = colors[2];
        endColor = colors[3];
        factor = (colorVal - phaseDuration * 2) / phaseDuration;
      }

      figures.ccCircle.fill = interpolateColor(startColor, endColor, factor);

      const moveDur = 3;
      const moveVal = (time % (moveDur * 2)) / (moveDur * 2);
      figures.movCircle.y = 1 - 0.25 * (1 + Math.sin(moveVal * 2 * Math.PI - Math.PI/2));

      const rotDur = 15;
      figures.rotRect.rotation = ((time % rotDur) / rotDur) * 2 * Math.PI;

      const scaleDur = 5;
      const scaleVal = (time % scaleDur) / scaleDur;
      let rx = 1;
      if (scaleVal < 0.25) rx = 1 - 2 * scaleVal;
      else if (scaleVal < 0.5) rx = 0.5 + 4 * (scaleVal - 0.25);
      else rx = 1.5 - 1 * (scaleVal - 0.5) / 0.5;
      figures.sEllipse.rx = rx;

      const skewDur = 4;
      const skewVal = (time % skewDur) / skewDur;
      let skewAngle = 0;
      if (skewVal < 0.25) skewAngle = 80 * skewVal;
      else if (skewVal < 0.5) skewAngle = 20 - 80 * (skewVal - 0.25);
      else if (skewVal < 0.75) skewAngle = -80 * (skewVal - 0.5);
      else skewAngle = -20 + 80 * (skewVal - 0.75);
      figures.skewRect.skewX = Math.tan(skewAngle * Math.PI / 180);

      figures.staticRect1.x = 4 + 0.5 * Math.sin(time);
      figures.staticRect2.x = 4 + 0.5 * Math.sin(time + Math.PI);
      figures.staticRect3.y = -2 + 0.5 * Math.sin(time * 2);
      figures.staticRect4.y = -1 - 0.5 * Math.sin(time * 2 + Math.PI);

      drawFigures();
      requestAnimationFrame(updateAnimation);
    };

    document.getElementById('animateButton').onclick = () => {
      if (!animationRunning) {
        animationRunning = true;
        startTime = 0;
        requestAnimationFrame(updateAnimation);
        document.getElementById('animateButton').textContent = "Зупинити анімацію";
      } else {
        animationRunning = false;
        document.getElementById('animateButton').textContent = "Запустити анімацію (Подія)";
        drawFigures();
      }
    };

    drawFigures();
  });
</script>

</body>
</html>
